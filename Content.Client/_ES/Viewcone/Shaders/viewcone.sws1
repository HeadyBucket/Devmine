uniform sampler2D SCREEN_TEXTURE;
uniform highp float Zoom;

uniform highp float ConeAngle; //= 270.0
uniform highp float ConeFeather; //= 10.0;
uniform highp float ConeIgnoreRadius; //= 0.5;
uniform highp float ConeIgnoreFeather; //= 0.1;

uniform highp float ViewAngle;

const highp float grainFramerate = 16.0;
const highp float grainTimeAffect = 1000.0;
const highp float grainScale = 400.0;
const highp float grainMult = 0.25;
const highp float grainAdd = 0.4;

const highp float grayscaleFactor = 0.85;

void fragment(){
    highp vec2 pixelSize = vec2(1.0/SCREEN_PIXEL_SIZE.x, 1.0/SCREEN_PIXEL_SIZE.y);
    highp float aspectratio = pixelSize.x / pixelSize.y;
    highp vec4 color = zTextureSpec(SCREEN_TEXTURE, Pos);

    highp float mask = 1.0;

    // IgnoreRadius pass
    highp float radial = zCircleGradient(pixelSize, FRAGCOORD.xy, 1.0, (ConeIgnoreFeather) / 1.0, (ConeIgnoreRadius / pow(ConeIgnoreFeather, 0.85)) / Zoom, 1.0);
    mask -= radial;

    // Setup for cone pass - this makes a gradient based around the angle to the center of the screen
    highp vec2 delta = FRAGCOORD.xy - (pixelSize * 0.5);
    highp float deltaAngle = atan(delta.x, delta.y);
    deltaAngle += ViewAngle;
    deltaAngle = mod(deltaAngle, radians(360.0));
    deltaAngle = abs(radians(180.0) - mod(deltaAngle, radians(360.0)));

    // The pass that actually renders the cone
    highp float radAngle = radians(ConeAngle);
    highp float radFeather = radians(ConeFeather) + pow(1.0 - radial, 2.0);
    deltaAngle = 1.0 - clamp((deltaAngle - (radAngle * 0.5)) + (radFeather * 0.5), 0.0, radFeather) / radFeather;
    mask += clamp(deltaAngle, 0.0, 1.0);

    mask = 1.0 - clamp(mask, 0.0, 1.0);

    // Just a lil bit of film grain
    highp float theframe = (floor(fract(TIME) * grainFramerate) * grainTimeAffect);
    highp float filmgrain = zNoise(vec2(Pos.x, Pos.y / aspectratio) * (grainScale * Zoom) + theframe);

    // Lil bit of grayscale for good measure, too
    highp float grayscale = zGrayscale(color.rgb) * (filmgrain * grainMult + grainAdd);

    COLOR = vec4(mix(color.rgb, vec3(grayscale), mask * grayscaleFactor), color.a);
}